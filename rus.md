#BEMIT: Расширяем BEM CSS нотацию на шаг вперёд
5 августа 2015

Любой, кто читает меня или наблюдает за моей работой даже небольшое время знает, что я горячо рекомендую [BEM CSS нотацию][1].
То, о чем я хотел бы рассказать в этом посте, не является альтернативой или вариантом другого синтаксиса БЭМ, а его развитием:
это небольшие дополнения, который поднимают БЭМ **notch**.
Я назвал это расширение синтаксиса *BEMIT*, т.к. оно берет идеи и некоторые паттерны из (так и не опубликованной)[Inverted Triangle CSS architecture]. BEM + ITCSS = BEMIT.

Напомню БЭМ разделяет все классы на 3 группы:
*   **Блок:** — корень блока-компонента
*   **Элемент:** — часть блока
*   **Модификатор:** — вариация или расширение блока

Блок, Элемент, Модификатор: БЭМ. Абсолютно любой класс в проекте вписывается в одну из этих категорий,
поэтому БЭМ так прекрасен своей простотой и понятностью.

Суть БЭМ в том чтобы сделать ваш код прозрачней и понятней. БЭМ показыват разработчикам как классы относятся один к одному,
что особенно полезно в сложных или глубоких частях DOM. Например, если бы я попросил вас удалить все классы относящиеся к юзеру в этом куске кода,
какие бы вы выбросили?

    <div class="media  user  premium">
      <img src="" alt="" class="img  photo  avatar" />
      <p class="body  bio">...</p>
    </div>
    

Наверное вы бы начали с `user`, но обо всем остальное вы должны были бы догадываться, изучать или пытаться разобраться как-то ещё.
Однако, если мы перепишем это с помощью BEM:

    <div class="media  user  user--premium">
      <img src="" alt="" class="media__img  user__photo  avatar" />
      <p class="media__body  user__bio">...</p>
    </div>
    

Тут мы можем сразу увидеть что `user`, `user--premium`, `user__photo` и
`user__bio` взаимосвязанны. Также мы можем увидеть что `media`,
`media__img` и `media__body` связанны, и что `avatar` это просто одинокий Блок без своих собственных Элементов или Модификаторов.


Круто что мы можем узнать все это только лишь из имен наших классов!
Это позволяет нам принимать более правильные и обдуманные решения про то как работает наш код и как мы можем это использовать, изменять и удалять.

Единственный недостаток БЭМ в том, что именование классов показывает только то, как элементы связаны друг с другом. Оно не дает представление об их поведении, как они действуют или как их надо имплементировать вне контекста связей между ними.


В связи с этим я решил расширить БЭМ до BEMIT. BEMIT не добавляет никаких других типов классов, у нас по прежнему остаются только Блоки,
Элементы или Модификаторы, но он добавляет информацию об использовании и состоянии.


## Пространства имён

Чтобы мне не повторятся, вам возможно лучше обраться к моей ранней статье в этом году -
[More Transparent UI Code with Namespaces][3], в котором я представил идею добавления префиксов определенного вида для каждого класса с,
который был пояснял разработчикам что именно этот класс делает. Такое именование в стиле [венгерской нотации][4] позволит нам установить
какую задачу должен выполнять каждый класс, как и где мы может его использовать повторно (если можем), можем мы или нет его модифицировать,
и многое другое. Эта статья довольно большая, но она позволит вам лучше понимать эту технику.

Наиболее распространенные пространства имен это:
`c-` — для компонентов,
`o-` — для объектов,
`u-` — для утилит
и `is-/has-` для состояний (они более подробно описаны в связанной статье).

С учетом этого приведенный HTML может быть переписан следующим образом:

    <div class="o-media  c-user  c-user--premium">
      <img src="" alt="" class="o-media__img  c-user__photo  c-avatar" />
      <p class="o-media__body  c-user__bio">...</p>
    </div>
    
Теперь, я могу видеть что у нас есть повторноиспользуемая абстракция (из OOCSS) [Медиа-объект][5] (`o-media*`)
и две реализации конкретных компонентов (`c-user*` and `c-avatar`).
Эти классы по прежнему являются Блоками, Элементами или Модификаторами: мы не добавили к ним новых классов, но мы добавили дополнительный логический уровень.

Эти пространства имен связанны со слоями что мы можем найти в Inverted Triangle CSS
архитектуре. Я имею в виду что у каждого класс а теперь есть свое местожительство в вашем проекте (и вашей файловой системе).

## Responsive-суффиксы

Следующая вещь, которую BEMIT добавляет в традиционную БЭМ-нотацию, это отзывчивые суффиксы.
Эти суффиксы имею формат `@<breakpoint>` и описывают связь этого класса с медиа-состоянием.

    <div class="o-media@md  c-user  c-user--premium">
      <img src="" alt="" class="o-media__img@md  c-user__photo  c-avatar" />
      <p class="o-media__body@md  c-user__bio">...</p>
    </div>
    
Например тут у нас есть `o-media@md`, что означает что это медиа-объект для набора правил медиа-состояния `md`.
Вот ещё возможные варианты:

*   `u-hidden@print` – вспомогательный класс для скрытия блоков в состоянии для печати.
*   `u-1/4@lg` – вспомогательный класс чтоб уменьшить что-то в 4 раза для медиа-состояния 'большая остановка`.
*   `o-layout@md` – объект раскладки для медиа-состояния 'средняя остановка`.

Символ `@` легко читается и имеет логическое значение для обозначения условных состояний.
Это позволит разработчикам просто взглянув на него, понять какие потенциальные перестановки или изменения могут быть у этого кусочка интерфейса.

**N.B.**: Вам необходимо экранировать символ `@` в вашем CSS-файле:

    @media print {
    
      .u-hidden\@print {
        display: none;
      }
    
    }
    

## Проверка жизнеспособности кода

Внедрив эти строгие и последовательные паттерны в свой HTML мы можем делать множество вещей.
В первую очередь, и самое главное, мы сможем писать гораздо более выразительный и качественный код интерфейсов для наших коллег,
подразумевая что им будет гораздо легче изучить состояние и сделать выводы о частях нового проекта.
И они тоже смогут снести свой вклад таким же образом.

Но другой приятный побочный эффект заключается в том, что мы получаем возможность визуально оценить жизнеспособность нашего кода.
Используя substring-селекторы, мы может выделить и отрисовать основную раскладку страницы, полагаясь на типы классов из которых она состоит:


    /**
     * Outline all classes.
     */
    [class] {
      outline: 5px solid lightgrey;
    }
    
    /**
     * Outline all BEM Elements.
     */
    [class*="__"] {
      outline: 5px solid grey;
    }
    
    /**
     * Outline all BEM Modifiers.
     */
    [class*="--"] {
      outline: 5px solid darkgrey;
    }
    
    /**
     * Outline all Object classes.
     */
    [class^="o-"],
    [class*=" o-"] {
      outline: 5px solid orange;
    }
    
    /**
     * Outline all Component classes.
     */
    [class^="c-"],
    [class*=" c-"] {
      outline: 5px solid cyan;
    }
    
    /**
     * Outline all Responsive classes.
     */
    [class*="@"] {
      outline: 5px solid rosybrown;
    }
    
    /**
     * Outline all Hack classes.
     */
    [class^="_"] {
      outline: 5px solid red;
    }
    

Конечно, это не пуленепробиваемое решение — что-то может быть одновременно и Компонентом и Элементом и Отзывчивым классом, но
если мы пишем классы стараясь соблюдать порядок (т.е. в порядке от наименнее до наиболее важное, от наиболее важных вещей, так что хаки записываются последними), мы можем получить красивый визуальный снимок верстки любой страницы.
Вы можете прочитать больше о преимуществах этого выделения в [моей предыдущей статье про пространства имен][6].

Мы можем отобразить это проверку различными способами, но пожалй наиболее простым будет добавить следующее в [Глобальный класс][7]:

    .s-healthcheck {
    
      ...
    
      /**
       * Outline all Responsive classes.
       */
      [class*="@"] {
        outline: 5px solid rosybrown;
      }
    
      ...
    
    }
    

…и вы вы можете добавить их к вашему `html`-элементу когда вы захотите включить это:

    <html class="s-healthcheck">
    

## Напоследок

Итак, у нас есть несколько простых добавлений для БЭМ, чтоб превратить его в BEMIT: добавление информации в начало и конец стандартных классов
Блока, Элемента и Модификатора, дает нам дополнительные знания о том, как эти классы ведут себя вне контекста связей между ними.
Ещё немного примеров:

    .c-page-head {}
    
    @media screen and (min-width: 15em) {
      .u-text-center\@sm {}
    }
    
    .o-layout__item {}
    
    @media print {
      .u-color-black\@print {}
    }


 [1]: http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/
 [2]: https://twitter.com/itcss_io
 [3]: http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/
 [4]: https://en.wikipedia.org/wiki/Hungarian_notation

 [5]: http://www.stubbornella.org/content/2010/06/25/the-media-object-saves-hundreds-of-lines-of-code/

 [6]: http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/#highlight-types-of-namespace

 [7]: http://csswizardry.com/2015/03/more-transparent-ui-code-with-namespaces/#scope-namespaces-s-
